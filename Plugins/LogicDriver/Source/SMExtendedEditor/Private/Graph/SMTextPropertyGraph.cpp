// Copyright Recursoft LLC 2019-2022. All Rights Reserved.

#include "SMTextPropertyGraph.h"
#include "SMEditorTextGraphLogging.h"
#include "STextPropertyEditableTextBox.h"
#include "Configuration/SMTextGraphEditorSettings.h"
#include "Nodes/PropertyNodes/SMGraphK2Node_TextPropertyNode.h"
#include "Text/SMTextParsing.h"
#include "Utilities/SMTextGraphUtils.h"

#include "Configuration/SMProjectEditorSettings.h"
#include "Construction/SMEditorConstructionManager.h"
#include "Graph/Nodes/SMGraphNode_StateNode.h"
#include "Utilities/SMBlueprintEditorUtils.h"
#include "Utilities/SMTextUtils.h"

#include "Editor.h"
#include "GraphEditAction.h"
#include "K2Node_FormatText.h"
#include "K2Node_VariableGet.h"
#include "ScopedTransaction.h"
#include "TimerManager.h"
#include "Internationalization/StringTableCore.h"
#include "Internationalization/StringTableRegistry.h"

/** SGraphPinText.cpp contains a private definition. We really just need access to the protected StaticStableTextId of IEditableTextProperty */
class FOurEditableTextGraphPin : public IEditableTextProperty
{
public:
	FOurEditableTextGraphPin(UEdGraphPin* InGraphPinObj)
		: GraphPinObj(InGraphPinObj)
	{
	}

	virtual bool IsMultiLineText() const override
	{
		return true;
	}

	virtual bool IsPassword() const override
	{
		return false;
	}

	virtual bool IsReadOnly() const override
	{
		return GraphPinObj->bDefaultValueIsReadOnly;
	}

	virtual bool IsDefaultValue() const override
	{
		FString TextAsString;
		FTextStringHelper::WriteToBuffer(TextAsString, GraphPinObj->DefaultTextValue);
		return TextAsString.Equals(GraphPinObj->AutogeneratedDefaultValue, ESearchCase::CaseSensitive);
	}

	virtual FText GetToolTipText() const override
	{
		return FText::GetEmpty();
	}

	virtual int32 GetNumTexts() const override
	{
		return 1;
	}

	virtual FText GetText(const int32 InIndex) const override
	{
		check(InIndex == 0);
		return GraphPinObj->DefaultTextValue;
	}

	virtual void SetText(const int32 InIndex, const FText& InText) override
	{
		check(InIndex == 0);
		GraphPinObj->Modify();
		GraphPinObj->GetSchema()->TrySetDefaultText(*GraphPinObj, InText);
	}

	virtual bool IsValidText(const FText& InText, FText& OutErrorMsg) const override
	{
		return true;
	}

#if USE_STABLE_LOCALIZATION_KEYS
	virtual void GetStableTextId(const int32 InIndex, const ETextPropertyEditAction InEditAction, const FString& InTextSource, const FString& InProposedNamespace, const FString& InProposedKey, FString& OutStableNamespace, FString& OutStableKey) const override
	{
		check(InIndex == 0);
		return StaticStableTextId(GraphPinObj->GetOwningNodeUnchecked(), InEditAction, InTextSource, InProposedNamespace, InProposedKey, OutStableNamespace, OutStableKey);
	}
#endif // USE_STABLE_LOCALIZATION_KEYS

	UEdGraphPin* GraphPinObj;
};


USMTextPropertyGraph::USMTextPropertyGraph(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer), FormatTextNode(nullptr), bIsUpdatingGraph(false),
	  bUpdatingFromFormatTextNode(false), bUpdatingStringTableLocalizationDisplay(false), bIsEditUndo(false),
	  bHasVariableParsingError(false)
{
	BindLocalizationDisplayChangeDelegate();
}

USMTextPropertyGraph::~USMTextPropertyGraph()
{
	UnbindLocalizationDisplayChangeDelegate();
}

UEdGraphPin* USMTextPropertyGraph::GetFormatTextNodePinChecked() const
{
	check(FormatTextNode);
	return FormatTextNode->FindPinChecked(TEXT("Format")); // Can't use GetFormatPin because it uses cached data which could be invalidated on edit undo.
}

void USMTextPropertyGraph::PostEditUndo()
{
	bIsEditUndo = true;
	// The serialization hash isn't always transacted, forcing a full graph refresh in this case is acceptable.
	TextSerializationFunctionHash = 0;
	Super::PostEditUndo();
	// If the graph was deleted we need to rebind the delegate.
	BindLocalizationDisplayChangeDelegate();
	bIsEditUndo = false;
}

void USMTextPropertyGraph::NotifyGraphChanged()
{
	Super::NotifyGraphChanged();
	SetTextFromFormatTextNode();
}

void USMTextPropertyGraph::NotifyGraphChanged(const FEdGraphEditAction& Action)
{
	Super::NotifyGraphChanged(Action);

	if((Action.Action & EEdGraphActionType::GRAPHACTION_AddNode) && Action.bUserInvoked && Action.Graph == this && !IsGraphBeingUsedToEdit())
	{
		/*
		 * A user drag dropping a text variable directly on the localization pin will try and connect the variable to the format pin.
		 * To avoid that we're adding the format pin as a restriction. After add node completes it will call the schema to try and create the connection
		 * at which point we will cancel it.
		*/
		if (Action.Nodes.Num() > 0)
		{
			PreventConnections.Reset();
			PreventConnections.Add(GetFormatTextNodePinChecked());
		}
	}
}

void USMTextPropertyGraph::RefreshProperty(bool bModify, bool bSetFromPinFirst)
{
	Super::RefreshProperty(bModify, bSetFromPinFirst);
	bEditable = IsGraphBeingUsedToEdit();

	bool bNeedsFullRefresh = false;

	// Check for updated serialization settings which could impact objects in the text graph.
	if ((StoredProperties.Num() > 0 || StoredFunctions.Num() > 0) && (!bIsEditUndo && !GIsTransacting && ResultNode))
	{
		if (const USMGraphNode_Base* OwningGraphNode = ResultNode->GetOwningGraphNode())
		{
			// Refreshing can happen multiple times, but we only need to do this on pre-compile so any updated
			// serialization functions are compiled / cooked.
			if (OwningGraphNode->IsPreCompiling())
			{
				if (FSMTextGraphProperty* PropertyNode = static_cast<FSMTextGraphProperty*>(ResultNode->GetPropertyNode()))
				{
					// If serialization settings have changed we should recreate the text graph to make sure we have the latest
					// functions.
					const uint32 CurrentHash = GetCurrentSerializationFunctionHash(PropertyNode);
					if (TextSerializationFunctionHash != CurrentHash)
					{
						// Save the current hash, it's not guaranteed to update later. Not setting it can lead to this
						// branch being run multiple times and producing unknown function errors during nativization.
						TextSerializationFunctionHash = CurrentHash;
						bNeedsFullRefresh = true;
					}
				}
			}
		}
	}

	const bool bResetGraph = bNeedsFullRefresh;

	// This transaction should only be necessary when a full refresh occurs. This happens during pre-compile when we would
	// prefer it not to be transacted and add to the undo history, but it seems unavoidable because of the graph reset.
	// Without it individual node removal and pin breakage would transact and undoing them individually isn't safe and
	// can crash. TODO: Try to avoid any transactions on ResetGraph when bModify is false.
	const FScopedTransaction Transaction(NSLOCTEXT("SMTextPropertyGraph", "RefreshTextGraph", "Refresh Text Graph"), !GIsTransacting);

	RefreshTextBody(bModify, bResetGraph);
	PruneDisconnectedNodes();
}

void USMTextPropertyGraph::ResetGraph()
{
	if (IsGraphBeingUsedToEdit())
	{
		return;
	}

	const FScopedTransaction Transaction(NSLOCTEXT("SMTextPropertyGraph", "ResetTextGraph", "Reset Text Graph"), !GIsTransacting);

	bIsUpdatingGraph = true;

	// Backup the default value so we can save localization settings.
	FText DefaultValue;
	if (UEdGraphPin* Pin = GetFormatTextNodePinChecked())
	{
		DefaultValue = Pin->DefaultTextValue;
	}

	bInitPropertyNodesOnReset = false;
	Super::ResetGraph();
	bInitPropertyNodesOnReset = true;

	// Restore the default value.
	if (UEdGraphPin* Pin = GetFormatTextNodePinChecked())
	{
		Pin->GetSchema()->TrySetDefaultText(*Pin, DefaultValue);
	}

	// Call here instead of in super so default format pin value is set correctly.
	ResultNode->OwningGraphNode->InitPropertyGraphNodes(this, ResultNode->GetPropertyNode());

	bIsUpdatingGraph = false;
}

void USMTextPropertyGraph::SetUsingGraphToEdit(bool bValue, bool bModify)
{
	auto MethodBody = [&]()
	{
		Super::SetUsingGraphToEdit(bValue, bModify);
		if (bValue)
		{
			SetTextEditMode(false);
		}
	};

	if (bModify)
	{
		const FScopedTransaction Transaction(NSLOCTEXT("SMTextPropertyGraph", "GraphEdit", "Graph Edit"));
		MethodBody();
	}
	else
	{
		MethodBody();
	}
}

bool USMTextPropertyGraph::IsGraphBeingUsedToEdit() const
{
	if (IsVariableReadOnly())
	{
		return false;
	}
	return bUpdatingFromFormatTextNode ? false : Super::IsGraphBeingUsedToEdit();
}

void USMTextPropertyGraph::OnGraphManuallyCloned(USMPropertyGraph* OldGraph)
{
	Super::OnGraphManuallyCloned(OldGraph);
	PruneDisconnectedNodes();
	FindAndSetFormatTextNode();
	USMTextPropertyGraph* OldTextGraph = CastChecked<USMTextPropertyGraph>(OldGraph);
	RichTextBody = OldTextGraph->RichTextBody;
	StoredFunctions = OldTextGraph->StoredFunctions;
	StoredProperties = OldTextGraph->StoredProperties;
	bEditable = OldGraph->bEditable;
}

void USMTextPropertyGraph::OnGraphDeleted()
{
	// Deleting the graph won't call the destructor. The delegate would still fire but this graph will be under the
	// transient package and crash when the BP is looked up since the result is checked.
	UnbindLocalizationDisplayChangeDelegate();
	Super::OnGraphDeleted();
}

void USMTextPropertyGraph::CommitNewText(const FText& PlainText)
{
	// Don't commit if text body hasn't changed. Localization can't change
	// from here and doesn't need to be checked.
	const FText CurrentText = GetFormatTextNodeText();
	if (!PlainText.ToString().Equals(CurrentText.ToString()))
	{
		SetNewText(PlainText, true, true);
	}
}

void USMTextPropertyGraph::SetNewText(const FText& PlainText, bool bReformatGraph, bool bModify)
{
	const FScopedTransaction Transaction(NSLOCTEXT("SMTextPropertyGraph", "SetText", "Set Text"));
	SetNewText_NoTransaction(PlainText, bReformatGraph, bModify);
}

void USMTextPropertyGraph::SetNewText_NoTransaction(const FText& PlainText, bool bReformatGraph, bool bModify)
{
	if (bModify)
	{
		Modify();
	}
	if (bReformatGraph)
	{
		ResetGraph();
	}

	SetTextBody(PlainText, bModify, bReformatGraph);
}

void USMTextPropertyGraph::RefreshTextBody(bool bModify, bool bResetGraph, bool bOnlyIfChanged)
{
	const FText PlainText = GetFormatTextNodeText();

	// Check if this is running for a construction script. In this case we only can refresh if the default
	// value has changed in the construction script. There isn't a risk to variables missing since they
	// can't be added to the blueprint at this stage.
	if (bOnlyIfChanged)
	{
		if (USMBlueprint* Blueprint = Cast<USMBlueprint>(FSMBlueprintEditorUtils::FindBlueprintForGraph(this)))
		{
			if (ResultNode && FSMEditorConstructionManager::GetInstance()->IsRunningConstructionScripts(Blueprint))
			{
				if (USMNodeInstance* Template = ResultNode->GetOwningTemplate())
				{
					if (const FSMTextGraphProperty* TextGraphProperty = CastChecked<USMGraphK2Node_TextPropertyNode>(ResultNode)->GetTextGraphProperty(Template))
					{
						if (TextGraphProperty->Result.EqualTo(PlainText, ETextComparisonLevel::Quinary))
						{
							// Default value hasn't changed, no need to process further.
							return;
						}
					}
				}
			}
		}
	}

	if (bResetGraph)
	{
		// This will still transact even if bModify is false!
		ResetGraph();
	}

	SetTextBody(PlainText, bModify);
}

void USMTextPropertyGraph::SetTextBody(const FText& PlainText, bool bModify, bool bReformatGraph)
{
	if (IsGraphBeingUsedToEdit())
	{
		return;
	}

	bIsUpdatingGraph = true;

	if (bModify)
	{
		Modify();
	}

	UBlueprint* Blueprint = FSMBlueprintEditorUtils::FindBlueprintForGraphChecked(this);
	SMTextParser::FParserResults ParserResult = SMTextParser::ConvertToRichText(PlainText, Blueprint, &StoredProperties, &StoredFunctions);
	bHasVariableParsingError = ParserResult.bErrorProcessing;

	bool bForceSet = ParserResult.bVarRenamed;

	PlainStringBody = PlainText.ToString();
	RichTextBody = ParserResult.RichText;

	if (FormatTextNode != nullptr)
	{
		if (bModify)
		{
			FormatTextNode->Modify();
		}

		// Determine the plain text to use for the format text node.
		FText FormatTextNodeText;
		if (!bReformatGraph || PlainText.IsFromStringTable())
		{
			// Either the string table handles localization (and var names) or the graph isn't
			// being reformatted and variables won't reset.
			FormatTextNodeText = PlainText;
		}
		else
		{
			// Use the parser result which will have adjusted the custom runs in the {%s} format.
			// The localization needs to be migrated from the original plain text as it will vary at this point.
			// If it's not corrected the namespace won't match and there will be a duplicate during text gathering.

			TOptional<FString> Namespace = FTextInspector::GetNamespace(PlainText);
			TOptional<FString> Key = FTextInspector::GetKey(PlainText);
			if (Namespace.IsSet() && Key.IsSet())
			{
				FormatTextNodeText = FText::ChangeKey(*Namespace, *Key, ParserResult.PlainText);
			}
			else
			{
				FormatTextNodeText = PlainText.IsCultureInvariant() ?
					FText::AsCultureInvariant(MoveTemp(ParserResult.PlainText)) : MoveTemp(ParserResult.PlainText);
			}
		}

		// Will get the format text node to display variable options.
		SetFormatTextNodeText(FormatTextNodeText, bForceSet);

		if (bReformatGraph)
		{
			checkSlow(ResultNode && ResultNode->OwningGraphNode);

			// Reset after parse now that they have been checked against.
			StoredProperties.Reset();
			StoredFunctions.Reset();
			ResultNode->OwningGraphNode->ResetLogMessages();

			FSMTextGraphProperty* PropertyNode = static_cast<FSMTextGraphProperty*>(ResultNode->GetPropertyNodeChecked());

			const bool bHasCustomSerializer = PropertyNode->TextSerializer.HasToTextFunctions() ||
				!GetDefault<USMTextGraphEditorSettings>()->ToTextDynamicFunctionName.IsNone();

			bool bConversionNodePlaced = false;

			for (UFunction* Function : ParserResult.Functions)
			{
				FGuid FunctionGuid;
				if (Blueprint->GetFunctionGuidFromClassByFieldName(Blueprint->SkeletonGeneratedClass, Function->GetFName(), FunctionGuid))
				{
					StoredFunctions.Add(Function->GetFName(), FunctionGuid);
				}
				UEdGraphPin* ArgumentPin = FormatTextNode->FindArgumentPin(Function->GetFName());
				if (!ArgumentPin)
				{
					FSMGraphNodeLog NodeLog(EMessageSeverity::Error);
					NodeLog.ConsoleMessage = TEXT("Could not find argument pin for node @@.");
					NodeLog.NodeMessage = FString::Printf(TEXT("Referenced function %s could not be placed!"), *Function->GetName());
					NodeLog.ReferenceList.Add(FormatTextNode);
					ResultNode->OwningGraphNode->AddNodeLogMessage(NodeLog);
				}
				else if (ArgumentPin->LinkedTo.Num() == 0)
				{
					UEdGraphNode* PlacedNode = nullptr;
					UEdGraphPin* FunctionArgumentPin = nullptr;
					if (!FSMBlueprintEditorUtils::PlaceFunctionOnGraph(this, Function, ArgumentPin, &PlacedNode, &FunctionArgumentPin, -100.f, 100.f, !bHasCustomSerializer))
					{
						bool bManualTextConversionSuccess = false;
						if (FunctionArgumentPin)
						{
							bManualTextConversionSuccess = FSMTextGraphUtils::CreateTextConversionNode(this, FunctionArgumentPin, ArgumentPin, PropertyNode->TextSerializer) != nullptr;
						}

						if (!bManualTextConversionSuccess)
						{
							FSMGraphNodeLog NodeLog(EMessageSeverity::Error);
							NodeLog.ConsoleMessage = TEXT("Function node @@ could not be wired as a text argument.");
							NodeLog.NodeMessage = FString::Printf(TEXT("Referenced function %s could not be converted to text!"), *Function->GetName());
							NodeLog.ReferenceList.Add(PlacedNode);
							ResultNode->OwningGraphNode->AddNodeLogMessage(NodeLog);
						}
						else
						{
							bConversionNodePlaced = true;
						}
					}
				}
			}

			for (const auto& Variable : ParserResult.Variables)
			{
				// Store the found properties to be used as references in case a name changes.
				StoredProperties.Add(Variable.Key, Variable.Value);

				FProperty* Property = Variable.Value.IsValid() ? FSMBlueprintEditorUtils::GetPropertyForVariable(Blueprint, Variable.Key) : nullptr;
				if (Property == nullptr)
				{
					FSMGraphNodeLog NodeLog(EMessageSeverity::Error);
					NodeLog.ConsoleMessage = FString::Printf(TEXT("Referenced property %s in node @@ does not exist!"), *Variable.Key.ToString());
					NodeLog.NodeMessage = FString::Printf(TEXT("Referenced property %s does not exist!"), *Variable.Key.ToString());
					NodeLog.ReferenceList.Add(this);
					ResultNode->OwningGraphNode->AddNodeLogMessage(NodeLog);
					continue;
				}

				// The in pin to the text format node.
				UEdGraphPin* ArgumentPin = FormatTextNode->FindArgumentPin(Variable.Key);
				if (!ArgumentPin)
				{
					FSMGraphNodeLog NodeLog(EMessageSeverity::Error);
					NodeLog.ConsoleMessage = TEXT("Could not find argument pin for node @@.");
					NodeLog.NodeMessage = FString::Printf(TEXT("Referenced variable %s could not be placed!"), *Variable.Key.ToString());
					NodeLog.ReferenceList.Add(FormatTextNode);
					ResultNode->OwningGraphNode->AddNodeLogMessage(NodeLog);
				}
				else if (ArgumentPin->LinkedTo.Num() == 0)
				{
					UK2Node_VariableGet* PlacedNode = nullptr;
					if (!FSMBlueprintEditorUtils::PlacePropertyOnGraph(this, Property, ArgumentPin, &PlacedNode, -100, !bHasCustomSerializer))
					{
						bool bManualTextConversionSuccess = false;
						if (PlacedNode)
						{
							bManualTextConversionSuccess = FSMTextGraphUtils::CreateTextConversionNode(this, PlacedNode->GetValuePin(), ArgumentPin, PropertyNode->TextSerializer) != nullptr;
						}

						if (!bManualTextConversionSuccess)
						{
							FSMGraphNodeLog NodeLog(EMessageSeverity::Error);
							NodeLog.ConsoleMessage = TEXT("Variable node @@ could not be wired as a text argument.");
							NodeLog.NodeMessage = FString::Printf(TEXT("Referenced property %s could not be converted to text!"), *Variable.Key.ToString());
							NodeLog.ReferenceList.Add(PlacedNode);
							ResultNode->OwningGraphNode->AddNodeLogMessage(NodeLog);
						}
						else
						{
							bConversionNodePlaced = true;
						}
					}
				}
			}

			// Conversion nodes only placed if the graph was reset prior.
			if (bConversionNodePlaced)
			{
				// Store the current serialization settings so they can be checked for change later.
				TextSerializationFunctionHash = GetCurrentSerializationFunctionHash(PropertyNode);
			}
		}
	}

	// Conditional Compile Optimization - When an empty text becomes populated this ensures the node is refreshed.
	if (!FSMEditorConstructionManager::GetInstance()->IsRunningConstructionScripts() && ResultNode && ResultNode->OwningGraphNode)
	{
		ResultNode->OwningGraphNode->RequestSlateRefresh(true);
	}

	bIsUpdatingGraph = false;
}

FText USMTextPropertyGraph::GetRichTextBody() const
{
	return RichTextBody;
}

FText USMTextPropertyGraph::GetPlainTextBody() const
{
	return FText::FromString(PlainStringBody);
}

FText USMTextPropertyGraph::GetFormatTextNodeText() const
{
	const UEdGraphPin* FormatPin = GetFormatTextNodePinChecked();
	// Always use DefaultTextValue. If GetDefaultAsText is used the case where empty invariant text isn't handled.
	FText PlainText = FormatPin->DefaultTextValue;
	return MoveTemp(PlainText);
}

bool USMTextPropertyGraph::DoesPlainStringMatchFormatTextString() const
{
	return GetFormatTextNodePinChecked()->DefaultTextValue.ToString().Equals(PlainStringBody);
}

void USMTextPropertyGraph::SetTextEditMode(bool bValue)
{
	SwitchTextEditAction.ExecuteIfBound(bValue);
}

bool USMTextPropertyGraph::ContainsProperty(const FName& InName) const
{
	return StoredProperties.Contains(InName);
}

bool USMTextPropertyGraph::ContainsFunction(const FName& InName) const
{
	return StoredFunctions.Contains(InName);
}

FText MultipleValuesText(NSLOCTEXT("PropertyEditor", "MultipleValues", "Multiple Values"));

void USMTextPropertyGraph::SetFormatTextNodeText(const FText& NewText, bool bForceSet)
{
	if (!GIsEditor)
	{
		// GetStableTextId will fail if not in editor. This can happen if using play as stand alone game.
		// Normal UE4 behavior only has similar logic happening when committing new text, but we call
		// this on compile.
		return;
	}

	UEdGraphPin* FormatPin = GetFormatTextNodePinChecked();

	if (!EditableTextProperty.IsValid() || EditableTextProperty->GraphPinObj != FormatPin)
	{
		EditableTextProperty = MakeShared<FOurEditableTextGraphPin>(FormatPin);
	}

	const bool bIsStringTable = NewText.IsFromStringTable();

	const int32 NumTexts = EditableTextProperty->GetNumTexts();

	// Don't commit the Multiple Values text if there are multiple properties being set
	if (NumTexts > 0 && (NumTexts == 1 || !NewText.ToString().Equals(MultipleValuesText.ToString(), ESearchCase::CaseSensitive)))
	{
		FText TextErrorMsg;
		if (!EditableTextProperty->IsValidText(NewText, TextErrorMsg))
		{
			return;
		}

		for (int32 TextIndex = 0; TextIndex < NumTexts; ++TextIndex)
		{
			const FText PropertyValue = EditableTextProperty->GetText(TextIndex);

			// Only apply the change if the new text is different
			if (!bForceSet && LD::TextUtils::DoesTextValueAndLocalizationMatch(PropertyValue, NewText))
			{
				continue;
			}

			// Maintain culture invariance when editing the text
			if (PropertyValue.IsCultureInvariant())
			{
				EditableTextProperty->SetText(TextIndex, FText::AsCultureInvariant(NewText.ToString()));
				continue;
			}

			// Is the new text is empty, just use the empty instance
			if (NewText.IsEmpty())
			{
				EditableTextProperty->SetText(TextIndex, FText::GetEmpty());
				continue;
			}

			FString NewNamespace;
			FString NewKey;

			if (!bIsStringTable)
			{
#if USE_STABLE_LOCALIZATION_KEYS
				{
					// Get the stable namespace and key that we should use for this property
					const FString* TextSource = FTextInspector::GetSourceString(PropertyValue);

					const FString ProposedKey = FTextInspector::GetKey(PropertyValue).Get(FString());
					const FString ProposedNamespace = FTextInspector::GetNamespace(PropertyValue).Get(FString());

					EditableTextProperty->GetStableTextId(
					   TextIndex,
					   IEditableTextProperty::ETextPropertyEditAction::EditedSource,
					   TextSource ? *TextSource : FString(),
					   ProposedNamespace,
					   ProposedKey,
					   NewNamespace,
					   NewKey
				   );

					// The proposed key didn't take. Check if this is only because of internal references and not
					// because the user has multiple references to the same text.
					if (NewKey != ProposedKey && NewNamespace == ProposedNamespace && ResultNode->HasDefaultValueExplicitlyBeenChanged())
					{
						if (LD::TextUtils::SetTemporaryKeyForTextReferences(FormatTextNode, TextSource ? *TextSource : FString(), NewNamespace, ProposedKey, NewKey))
						{
							// Attempt to get the stable ID again, this time it should match the old key.
							EditableTextProperty->GetStableTextId(
							   TextIndex,
							   IEditableTextProperty::ETextPropertyEditAction::EditedSource,
							   TextSource ? *TextSource : FString(),
							   ProposedNamespace,
							   ProposedKey,
							   NewNamespace,
							   NewKey
						   );

							if (!ProposedKey.Equals(NewKey))
							{
								LDEDITOR_TEXTGRAPH_LOG_ERROR(TEXT("Failed to set stable localization key '%s'. Using new key '%s' instead."), *ProposedKey, *NewKey);
							}
						}
					}
				}
#else	// USE_STABLE_LOCALIZATION_KEYS
				{
					// We want to preserve the namespace set on this property if it's *not* the default value
					if (!EditableTextProperty->IsDefaultValue())
					{
						// Some properties report that they're not the default, but still haven't been set from a property, so we also check the property key to see if it's a valid GUID before allowing the namespace to persist
						FGuid TmpGuid;
						if (FGuid::Parse(FTextInspector::GetKey(PropertyValue).Get(FString()), TmpGuid))
						{
							NewNamespace = FTextInspector::GetNamespace(PropertyValue).Get(FString());
						}
					}

					NewKey = FGuid::NewGuid().ToString();
				}

#endif	// USE_STABLE_LOCALIZATION_KEYS
			}

			EditableTextProperty->SetText(TextIndex, bIsStringTable ? NewText : FText::ChangeKey(NewNamespace, NewKey, NewText));
			CastChecked<USMGraphK2Node_TextPropertyNode>(ResultNode)->NotifyFormatTextUpdated(NewText);
		}
	}
}

void USMTextPropertyGraph::FindAndSetFormatTextNode()
{
	// The first connected node to the result pin should be the format text node.
	UEdGraphPin** FormatTextPin = ResultNode->GetResultPinChecked()->LinkedTo.FindByPredicate([&](const UEdGraphPin* GraphPin)
	{
		return GraphPin->GetOwningNode()->IsA<UK2Node_FormatText>();
	});

	if (FormatTextPin)
	{
		FormatTextNode = Cast<UK2Node_FormatText>((*FormatTextPin)->GetOwningNode());
		return;
	}

	// Look back through connected nodes.
	TSet<UEdGraphNode*> ConnectedNodes;
	FSMBlueprintEditorUtils::GetAllConnectedNodes(ResultNode, EEdGraphPinDirection::EGPD_Input, ConnectedNodes);

	for (UEdGraphNode* ConnectedNode : ConnectedNodes)
	{
		if (UK2Node_FormatText* FormatNode = Cast<UK2Node_FormatText>(ConnectedNode))
		{
			FormatTextNode = FormatNode;
			return;
		}
	}

	// Last resort, take any node.
	FormatTextNode = FSMBlueprintEditorUtils::GetFirstNodeOfClassNested<UK2Node_FormatText>(this);
}

void USMTextPropertyGraph::SetTextFromFormatTextNode(bool bForce, bool bFromLocalizationDisplayChange)
{
	if (bUpdatingStringTableLocalizationDisplay)
	{
		bFromLocalizationDisplayChange = true;
	}
	const bool bIsLoading = HasAnyFlags(RF_NeedPostLoad) && HasAnyFlags(RF_NeedPostLoadSubobjects);
	const bool bLoadOkay = bFromLocalizationDisplayChange ? true : !bIsLoading;
	if (!bIsUpdatingGraph && bLoadOkay && !bUpdatingFromFormatTextNode &&
		GetPackage() != GetTransientPackage() && ResultNode && !ResultNode->GetOwningGraphNodeChecked()->IsEditUndo())
	{
		if (const UEdGraphPin* FormatTextPin = GetFormatTextNodePinChecked())
		{
			bUpdatingFromFormatTextNode = true;

			const FText FormatPinText = FormatTextPin->DefaultTextValue;
			const FString FormatPinString = FormatPinText.ToString();
			const bool bIsStringTable = FormatPinText.IsFromStringTable();

			const bool bStringTableOrGraphEdit = ((bIsStringTable || bEditable) && FormatPinString != PlainStringBody);
			const bool bLocalizationChange = !bStringTableOrGraphEdit &&
				!LD::TextUtils::DoesTextValueAndLocalizationMatch(
					ResultNode->GetLastAutoGeneratedDefaultValue(),
					LD::TextUtils::TextToStringBuffer(FormatPinText));

			if (bForce || bStringTableOrGraphEdit || bLocalizationChange)
			{
				if (bIsStringTable && !bUpdatingStringTableLocalizationDisplay &&
					FTextInspector::GetSourceString(FormatPinText) == &FStringTableEntry::GetPlaceholderSourceString())
				{
					FName TableId;
					FString Key;
					if (FTextInspector::GetTableIdAndKey(FormatPinText, TableId, Key)
						&& IStringTableEngineBridge::IsStringTableFromAsset(TableId))
					{
						auto OnTableLoaded = [=](FName TableRequested, FName TableLoaded)
						{
							if (GEditor && GEditor->IsTimerManagerValid() && IsValid(this))
							{
								// Even though the string table is loaded, the FText properties won't have updated
								// display text until the next tick.
								GEditor->GetTimerManager()->SetTimerForNextTick(
									FTimerDelegate::CreateLambda([=]()
								{
										if (!IsValid(this) || !IsValid(FormatTextNode) ||
											!ensure(!FormatTextNode->HasAnyFlags(RF_NeedInitialization) &&
											!ResultNode->HasAnyFlags(RF_NeedInitialization)))
										{
											return;
										}

										const bool bIsDirty = GetPackage()->IsDirty();

										bUpdatingStringTableLocalizationDisplay = true;
										FormatTextNode->ReconstructNode(); // This will trigger SetTextFromFormatTextNode.

										if (!bIsDirty)
										{
											// This is only a display text update and the format text should already be correct
											// so this package doesn't need to be saved.
											GetPackage()->ClearDirtyFlag();
										}

										bUpdatingStringTableLocalizationDisplay = false;
								}));
							}
						};

						IStringTableEngineBridge::LoadStringTableAsset(TableId, OnTableLoaded);
					}
				}
				else
				{
					// Don't physically regenerate the graph unless this is from a string table.
					// We don't want to accidentally destroy customized editable graphs.
					const bool bReformatGraph = bIsStringTable && !bFromLocalizationDisplayChange;

					if (bIsStringTable && !bIsEditUndo && !bFromLocalizationDisplayChange)
					{
						SetNewText(FormatPinText, bReformatGraph, true);
						const ESMEditorConstructionScriptProjectSetting ConstructionProjectSetting = FSMBlueprintEditorUtils::GetProjectEditorSettings()->EditorNodeConstructionScriptSetting;
						if (ConstructionProjectSetting == ESMEditorConstructionScriptProjectSetting::SM_Compile)
						{
							// Compile only construction scripts won't have LastAutoGeneratedDefaultValue set which will cause this method to
							// be triggered again through a graph reset because bLocalizationChange will be true. The pin text will be empty
							// and the string table value will be lost. It's probably safe to run this on all construction script types, but
							// isn't necessary because the default value will be set otherwise.

							ResultNode->SetPropertyDefaultsFromPin();
							ResultNode->SetPinValueFromPropertyDefaults(false, false, true);
						}
					}
					else
					{
						if (bIsLoading && bFromLocalizationDisplayChange && !bUpdatingStringTableLocalizationDisplay)
						{
							const USMGraphNode_StateNodeBase* OwningNode = Cast<USMGraphNode_StateNodeBase>(ResultNode->GetOwningGraphNode());
							const UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(this);
							LDEDITOR_TEXTGRAPH_LOG_WARNING(TEXT("\
Textgraph property '%s' on node '%s' may have saved the display text of a different language and is being corrected. Please verify \n\
the asset '%s' has the correct text for the current language. This error can occur if the asset is saved while PIE is running when previewing a different localization."),
							*GetName(), OwningNode ? *OwningNode->GetStateName() : TEXT("NULL"), Blueprint ? *Blueprint->GetName() : TEXT("NULL"));
						}

						// Always called when localization display is updating. Should be silent.
						SetNewText_NoTransaction(FormatPinText, bReformatGraph, false);
					}
					if (bIsStringTable)
					{
						SetUsingGraphToEdit(true, !bFromLocalizationDisplayChange);
					}
				}
			}

			bUpdatingFromFormatTextNode = false;
		}
	}
}

void USMTextPropertyGraph::HandleLocalizationDisplayChange()
{
	SetTextFromFormatTextNode(true, true);
}

void USMTextPropertyGraph::BindLocalizationDisplayChangeDelegate()
{
	if (!LocalizationDisplayChangeHandle.IsValid())
	{
		LocalizationDisplayChangeHandle = FTextLocalizationManager::Get().OnTextRevisionChangedEvent.AddUObject(this, &USMTextPropertyGraph::HandleLocalizationDisplayChange);
	}
}

void USMTextPropertyGraph::UnbindLocalizationDisplayChangeDelegate()
{
	if (LocalizationDisplayChangeHandle.IsValid())
	{
		FTextLocalizationManager::Get().OnTextRevisionChangedEvent.Remove(LocalizationDisplayChangeHandle);
		LocalizationDisplayChangeHandle.Reset();
	}
}

uint32 USMTextPropertyGraph::GetCurrentSerializationFunctionHash(FSMTextGraphProperty* PropertyNode) const
{
	const USMTextGraphEditorSettings* TextGraphEditorSettings = GetDefault<USMTextGraphEditorSettings>();
	return HashCombine(GetTypeHash(PropertyNode->TextSerializer), GetTypeHash(TextGraphEditorSettings->ToTextDynamicFunctionName));
}
