// Copyright Recursoft LLC 2019-2022. All Rights Reserved.

#include "SMGraphK2Node_PropertyNode.h"

#include "Blueprints/SMBlueprintEditor.h"
#include "Commands/SMEditorCommands.h"
#include "Construction/SMEditorConstructionManager.h"
#include "Graph/SMPropertyGraph.h"
#include "Graph/Nodes/SMGraphNode_Base.h"
#include "Graph/Nodes/SlateNodes/Properties/SSMGraphProperty.h"
#include "Utilities/SMBlueprintEditorUtils.h"
#include "Utilities/SMNodeInstanceUtils.h"
#include "Utilities/SMPropertyUtils.h"
#include "Utilities/SMTextUtils.h"

#include "FindInBlueprintManager.h"
#include "ScopedTransaction.h"
#include "ToolMenu.h"
#include "Components/HorizontalBox.h"
#include "Engine/UserDefinedEnum.h"
#include "Input/Reply.h"
#include "Internationalization/TextPackageNamespaceUtil.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "Utilities/SMIndexerUtils.h"
#include "Widgets/Input/SButton.h"

#define LOCTEXT_NAMESPACE "SMPropertyNode"

USMGraphK2Node_PropertyNode_Base::USMGraphK2Node_PropertyNode_Base(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer), OwningGraphNode(nullptr), bMouseOverNodeProperty(false), NotifyArgs(),
	  bDefaultValueChanged(false),
	  bGeneratedDefaultValueBeingSet(false), bSettingPropertyDefaultsFromPin(false), bResettingProperty(false)
{
}

USMGraphK2Node_PropertyNode_Base::~USMGraphK2Node_PropertyNode_Base()
{
	ForceVisualRefreshEvent.Clear();
}

FText USMGraphK2Node_PropertyNode_Base::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("Result", "Result");
}

FText USMGraphK2Node_PropertyNode_Base::GetTooltipText() const
{
	return LOCTEXT("GraphPropertyToolTip", "Evaluates the result for the graph property.");
}

void USMGraphK2Node_PropertyNode_Base::PostPlacedNewNode()
{
	Super::PostPlacedNewNode();

	// Possible this could be run from a state machine state node where there is no run-time container.
	if (USMGraphK2Node_RuntimeNodeContainer* Container = GetRuntimeContainer())
	{
		ContainerOwnerGuid = Container->ContainerOwnerGuid;
		RuntimeNodeGuid = Container->GetRunTimeNodeChecked()->GetNodeGuid();
	}
}

void USMGraphK2Node_PropertyNode_Base::ReconstructNode()
{
	// Pin default values need to be stored when they are equal to auto generated default values because UE will not
	// always copy default values during ReconstructSinglePin(). An example would be an int of 0 is saved to
	// DefaultValue as "0", but when DoesDefaultValueMatchAutogenerated() is called it treats "0" as the auto generated
	// default. Since that is true ReconstructSinglePin won't copy the "0" to the new pin. This may be fine for UE
	// operation, but Logic Driver needs to know the exact value for accurate comparisons.

	FString ResultPinSavedDefaultValue;
	FText ResultPinSavedDefaultTextValue;
	UObject* ResultPinSavedDefaultObject = nullptr;

	bool bRestoreDefaultValues = false;

	if (UEdGraphPin* ResultPin = GetResultPin())
	{
		if (const UEdGraphSchema* Schema = ResultPin->GetSchema())
		{
			if (Schema->DoesDefaultValueMatchAutogenerated(*ResultPin))
			{
				ResultPinSavedDefaultObject = ResultPin->DefaultObject;
				ResultPinSavedDefaultValue = ResultPin->DefaultValue;
				ResultPinSavedDefaultTextValue = ResultPin->DefaultTextValue;
				bRestoreDefaultValues = true;
			}
		}
	}

	Super::ReconstructNode();

	if (bRestoreDefaultValues)
	{
		if (UEdGraphPin* ResultPin = GetResultPin())
		{
			ResultPin->DefaultObject = ResultPinSavedDefaultObject;
			ResultPin->DefaultValue = ResultPinSavedDefaultValue;
			ResultPin->DefaultTextValue = ResultPinSavedDefaultTextValue;
		}
	}
}

void USMGraphK2Node_PropertyNode_Base::PinDefaultValueChanged(UEdGraphPin* Pin)
{
	if (Pin == GetResultPin())
	{
		// Only the autogenerated default value was changed. Handle it here.
		if (bGeneratedDefaultValueBeingSet || bSettingPropertyDefaultsFromPin)
		{
			return;
		}

		bDefaultValueChanged = true;

		/*
		 * HACK: Fix crash when placing a property directly on an object pin or when hovering an old object pin
		 * during reconstruction. This could happen if a dropdown enum list modifies the node through construction scripts
		 * and the entry you selected is over an object pin that is being destroyed.
		 * The slate pin is invalidated but UE will still try to use it reading tooltips next tick and check() the owning
		 * node which is null. The work around is to disable tool tips then wait two ticks before re-enabling tooltips.
		 */
		FSMBlueprintEditorUtils::DisableToolTipsTemporarily();
	}
	
	Super::PinDefaultValueChanged(Pin);
	
	if (USMGraphNode_Base* GraphNode = GetOwningGraphNode())
	{
		// Construction scripts will SetPropertyDefaultsFromPin which needs to happen at this stage.
		const ESMEditorConstructionScriptProjectSetting ConstructionProjectSetting = FSMBlueprintEditorUtils::GetProjectEditorSettings()->EditorNodeConstructionScriptSetting;
		if (ConstructionProjectSetting == ESMEditorConstructionScriptProjectSetting::SM_Standard)
		{
			FSMConstructionConfiguration Configuration;
			Configuration.bFullRefreshNeeded = false;
			FSMEditorConstructionManager::GetInstance()->RunAllConstructionScriptsForBlueprint(GraphNode, MoveTemp(Configuration));
		}
		else if (IsValid(this) && GetPackage() != GetTransientPackage() && IsValid(GetGraph()))
		{
			// The construction script handles this normally, but if it's not running the defaults should still be set.
			SetPropertyDefaultsFromPin();
			SetPinValueFromPropertyDefaults(false, false, true);
		}

		// Notify PostEditChangeProperty on the template so user editor code can respond to exposed property changes.
		if (USMNodeInstance* NodeTemplate = GetOwningTemplate())
		{
			const FSMGraphProperty_Base* GraphProperty = GetPropertyNodeConstChecked();
			if (FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(NodeTemplate->GetClass()))
			{
				NodeTemplate->bIsNodePinChanging = true;
				FPropertyChangedEvent PropertyChangedEvent(Property);
				NodeTemplate->PostEditChangeProperty(PropertyChangedEvent);
				NodeTemplate->bIsNodePinChanging = false;
			}
		}
	}
}

void USMGraphK2Node_PropertyNode_Base::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);
	// Warning. If the graph is being trashed this will cause a check fail.
	//SetPropertyDefaultsFromPin();

	if (Pin && Pin->LinkedTo.Num() > 0)
	{
		// Get all connected nodes because there could be autocast nodes placed as well.
		TSet<UEdGraphNode*> ConnectedNodes;
		FSMBlueprintEditorUtils::GetAllConnectedNodes(Pin->LinkedTo[0]->GetOwningNode(), EGPD_Input, ConnectedNodes);
		for (UEdGraphNode* OwningNode : ConnectedNodes)
		{
			if (USMPropertyGraph* PropertyGraph = GetPropertyGraph())
			{
				/*
				 * What's happening here is a connection is being made across graphs. This is likely
				 * from drag dropping a function DIRECTLY on the pin property value which is technically
				 * in the sm graph. We have handling outside of here to destroy those nodes when placed on the graph
				 * but it tries to forward valid nodes over a property here but can't get them all depending where on
				 * the pin it is dropped. We can salvage the connection here. Unfortunately an ensure is usually
				 * tripped before this point.
				 */
				if (OwningNode->GetGraph() != PropertyGraph)
				{
					OwningNode->Rename(nullptr, PropertyGraph,
						REN_DoNotDirty | REN_DontCreateRedirectors | REN_ForceNoResetLoaders);
					OwningNode->ClearFlags(RF_Transient);
					PropertyGraph->AddNode(OwningNode);
				}
			}
		}
	}
	
	// Pin is changed if user manually places and connects a value or if the value is dropped directly on the exposed k2 pin.
	ForceVisualRefresh();
}

bool USMGraphK2Node_PropertyNode_Base::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin,
                                                              FString& OutReason) const
{
	UEdGraphPin* ResultPin = GetResultPin();
	if (ResultPin && (ResultPin == MyPin || ResultPin == OtherPin))
	{
		if (const FSMGraphProperty_Base* Prop = GetPropertyNodeConst())
		{
			if (Prop->IsVariableReadOnly())
			{
				return true;
			}
		}
	}

	return Super::IsConnectionDisallowed(MyPin, OtherPin, OutReason);
}

bool USMGraphK2Node_PropertyNode_Base::HasExternalDependencies(TArray<UStruct*>* OptionalOutput) const
{
	const UBlueprint* SourceBlueprint = FBlueprintEditorUtils::FindBlueprintForNode(this);
	if (!SourceBlueprint)
	{
		// Possible to be null under rare conditions,
		// this method can be called prior to cleanup of this invalid node.
		return false;
	}
	
	USMNodeInstance* OwningTemplate = GetOwningTemplate();
	UClass* SourceClass = OwningTemplate ? OwningTemplate->GetClass() : nullptr;
	const bool bResult = (SourceClass != nullptr) && (SourceClass->ClassGeneratedBy != SourceBlueprint);
	if (bResult && OptionalOutput)
	{
		OptionalOutput->AddUnique(SourceClass);
	}
	const bool bSuperResult = Super::HasExternalDependencies(OptionalOutput);
	return bSuperResult || bResult;
}

void USMGraphK2Node_PropertyNode_Base::AddPinSearchMetaDataInfo(const UEdGraphPin* Pin,
	TArray<FSearchTagDataPair>& OutTaggedMetaData) const
{
	AddSharedPinSearchMetaDataInfo(OutTaggedMetaData);

	if (const UEdGraphPin* ResultPin = GetResultPin())
	{
		// User enums will only show NewEnumeratorX. We should show the actual defined value instead.
		if (ResultPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Byte ||
			ResultPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Enum)
		{
			if (UUserDefinedEnum* TypeEnum = Cast<UUserDefinedEnum>(ResultPin->PinType.PinSubCategoryObject.Get()))
			{
				const FString NewEnumeratorDefault = Pin->GetDefaultAsString();
				if (const FText* DisplayText = TypeEnum->DisplayNameMap.Find(*NewEnumeratorDefault))
				{
					OutTaggedMetaData.Add(FSearchTagDataPair(FFindInBlueprintSearchTags::FiB_Name, Pin->GetSchema()->GetPinDisplayName(Pin)));
					OutTaggedMetaData.Add(FSearchTagDataPair(FFindInBlueprintSearchTags::FiB_DefaultValue, *DisplayText));
					return;
				}
			}
		}

		Super::AddPinSearchMetaDataInfo(ResultPin, OutTaggedMetaData);
	}
	else
	{
		Super::AddPinSearchMetaDataInfo(Pin, OutTaggedMetaData);
	}
}

void USMGraphK2Node_PropertyNode_Base::AddSharedPinSearchMetaDataInfo(TArray<FSearchTagDataPair>& OutTaggedMetaData) const
{
	if (const USMGraphNode_Base* OwningNode = GetOwningGraphNode())
	{
		if (const FSMGraphProperty_Base* GraphProperty = GetPropertyNodeConst())
		{
			const FGuid& GraphPropertyGuid = GraphProperty->GetGuid();

			int32 ArrayIndex = INDEX_NONE;
			if (const USMNodeInstance* Template = GetOwningTemplate())
			{
				UClass* ClassToUse = Template->GetClass();
				if (GraphProperty->MemberReference.ResolveMember<FArrayProperty>(ClassToUse) != nullptr)
				{
					ArrayIndex = GraphProperty->ArrayIndex;
				}
			}

			const FString NodeData = FString::Printf(TEXT("_Name:{%s}_NodeGuid:{%s}_PropName:{%s}_PropGuid:{%s}_Arr:{%i}"),
				*OwningNode->GetNodeName(), *OwningNode->NodeGuid.ToString(), *GraphProperty->GetDisplayName().ToString(), *GraphPropertyGuid.ToString(), ArrayIndex);

			OutTaggedMetaData.Add(FSearchTagDataPair(FSMSearchTags::FiB_NodeData,
				FText::FromString(NodeData)));
		}
	}
}

void USMGraphK2Node_PropertyNode_Base::PreConsolidatedEventGraphValidate(FCompilerResultsLog& MessageLog)
{
	Super::PreConsolidatedEventGraphValidate(MessageLog);

	// Update the runtime node from the editor node.
	ConfigureRuntimePropertyNode();
	
	FSMGraphProperty_Base* GraphProperty = GetPropertyNodeConstChecked();
	if (GraphProperty->ShouldAutoAssignVariable())
	{
		if (UBlueprint* Blueprint = GetTemplateBlueprint())
		{
			FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(Blueprint);
			if (!Property)
			{
				MessageLog.Error(TEXT("Graph Property Node @@ can't find target property. Please recompile the blueprint @@."), this, Blueprint);
				return;
			}
		}
	}
}

void USMGraphK2Node_PropertyNode_Base::SetHighlight(bool bEnable, FLinearColor Color, bool bClearOnCompile)
{
	FHighlightArgs Args;
	Args.bEnable = bEnable;
	Args.Color = Color;
	Args.bClearOnCompile = bClearOnCompile;
	SetHighlightedArgs(MoveTemp(Args));
}

void USMGraphK2Node_PropertyNode_Base::SetNotification(bool bEnable, ESMLogType Severity,
	const FString& Message, bool bClearOnCompile)
{
	FNotifyArgs Args;
	Args.bEnable = bEnable;
	Args.bClearOnCompile = bClearOnCompile;
	Args.LogType = Severity;
	Args.Message = Message;
	SetNotificationArgs(MoveTemp(Args));
}

void USMGraphK2Node_PropertyNode_Base::SetNotificationAndHighlight(bool bEnable, ESMLogType Severity, const FString& Message,
	bool bClearOnCompile)
{
	SetNotification(bEnable, Severity, Message, bClearOnCompile);

	const FLinearColor HighlightColor = GetHighlightColorFromSeverity(Severity);
	SetHighlight(bEnable, HighlightColor, bClearOnCompile);
}

void USMGraphK2Node_PropertyNode_Base::ResetProperty()
{
	if (bResettingProperty)
	{
		return;
	}

	bResettingProperty = true;

	const FScopedTransaction Transaction(NSLOCTEXT("UnrealEd", "ResetProperty", "Reset Property"));

	USMPropertyGraph* PropertyGraph = GetPropertyGraph();
	PropertyGraph->SetUsingGraphToEdit(GetPropertyNodeConstChecked()->ShouldDefaultToEditMode());
	PropertyGraph->ResetGraph();

	bDefaultValueChanged = false;
	SetPinValueFromPropertyDefaults(false, /*bUseArchetype*/ true);
	// Make sure the archetype value is updated.
	SetPropertyDefaultsFromPin();

	USMGraphNode_Base* GraphNode = GetOwningGraphNode();
	check(GraphNode);

	const ESMEditorConstructionScriptProjectSetting ConstructionProjectSetting = FSMBlueprintEditorUtils::GetProjectEditorSettings()->EditorNodeConstructionScriptSetting;
	if (ConstructionProjectSetting == ESMEditorConstructionScriptProjectSetting::SM_Standard)
	{
		FSMConstructionConfiguration Configuration;
		Configuration.bFullRefreshNeeded = false;
		FSMEditorConstructionManager::GetInstance()->RunAllConstructionScriptsForBlueprint(GraphNode, MoveTemp(Configuration));
	}
	GraphNode->ReconstructNode();

	bResettingProperty = false;
}

void USMGraphK2Node_PropertyNode_Base::RefreshPropertyPinFromValue()
{
	if (!FSMEditorConstructionManager::GetInstance()->IsRunningConstructionScripts())
	{
		SetPinValueFromPropertyDefaults(false, false, true);
	}
}

void USMGraphK2Node_PropertyNode_Base::RefreshPropertyValueFromPin()
{
	if (!FSMEditorConstructionManager::GetInstance()->IsRunningConstructionScripts())
	{
		SetPropertyDefaultsFromPin();
	}
}

void USMGraphK2Node_PropertyNode_Base::PreCompileBeforeConstructionScripts(FSMKismetCompilerContext& CompilerContext)
{
	if (HighlightArgs.bClearOnCompile)
	{
		HighlightArgs = FHighlightArgs();
	}

	if (NotifyArgs.bClearOnCompile)
	{
		NotifyArgs = FNotifyArgs();
	}
}

FProperty* USMGraphK2Node_PropertyNode_Base::GetProperty() const
{
	if (const USMNodeInstance* NodeTemplate = GetOwningTemplate())
	{
		if (const FSMGraphProperty_Base* GraphProperty = GetPropertyNodeConst())
		{
			return GraphProperty->MemberReference.ResolveMember<FProperty>(NodeTemplate->GetClass());
		}
	}

	return nullptr;
}

void USMGraphK2Node_PropertyNode_Base::SetPropertyDefaultsFromPin()
{
	if (bSettingPropertyDefaultsFromPin || HasAnyFlags(RF_NeedPostLoad | RF_NeedPostLoadSubobjects))
	{
		return;
	}

	bSettingPropertyDefaultsFromPin = true;
	
	if (USMNodeInstance* Template = GetOwningTemplate())
	{
		// Ignore REINST classes.
		const UClass* Class = Template->GetClass();
		if (Class->GetName().StartsWith(TEXT("REINST_")))
		{
			return;
		}
		
		if (const UEdGraphPin* ResultPin = GetResultPin())
		{
			if (ResultPin->LinkedTo.Num() == 0)
			{
				const FSMGraphProperty_Base* GraphProperty = GetPropertyNodeChecked();

				UClass* ClassToUse = Template->GetClass();
				if (FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(ClassToUse))
				{
					Template->Modify();

					const FString DefaultValue = ResultPin->GetDefaultAsString();
					LD::PropertyUtils::SetPropertyValue(Property, DefaultValue, Template, GraphProperty->ArrayIndex);
					
					if (const USMGraphNode_Base* OwningNode = GetOwningGraphNode())
					{
						if (OwningNode->IsBeingPasted() || OwningNode->IsPreCompiling())
						{
							// Pasting and recompiling will run all construction scripts.
							bSettingPropertyDefaultsFromPin = false;
							return;
						}
					}
				}
			}
		}
	}

	bSettingPropertyDefaultsFromPin = false;
}

void USMGraphK2Node_PropertyNode_Base::SetPinValueFromPropertyDefaults(bool bUpdateTemplateDefaults, bool bUseArchetype, bool bForce)
{
	if (bResettingProperty)
	{
		// Never reset from the instance.
		bUseArchetype = true;
	}
	
	if (bDefaultValueChanged && !bForce)
	{
		/*
		 * Assume the pin is accurate and update the default value of the archetype. Pasting nodes doesn't grab the updated value
		 * when a variable name has a special character like `[` or `(` character in it. We think this is a problem with CopyPropertiesForUnrelatedObjects.
		 * Without this code default values may not be set and will require graph evaluation.
		 */
		if (bUpdateTemplateDefaults)
		{
			SetPropertyDefaultsFromPin();
		}
		return;
	}
	
	if (USMNodeInstance* Template = GetOwningTemplate())
	{
		// Ignore REINST classes.
		const UClass* Class = Template->GetClass();
		if (Class->GetName().StartsWith(TEXT("REINST_")))
		{
			return;
		}

		// Switch to the CDO so we can get the real defaults.
		Template = bUseArchetype ? CastChecked<USMNodeInstance>(Class->GetDefaultObject()) : Template;
		
		if (UEdGraphPin* ResultPin = GetResultPin())
		{
			// Only reset if the user hasn't changed the default value.
			// TODO: IsValueSetToDefault seems like it should be checked for false and bResettingProperty could be removed.
			if (bForce || bResettingProperty || IsValueSetToDefault())
			{
				const FSMGraphProperty_Base* GraphProperty = GetPropertyNodeChecked();
				if (FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(Template->GetClass()))
				{
					FString TextValue;
					
					if (const FArrayProperty* ArrayProperty = CastField<FArrayProperty>(Property))
					{
						FScriptArrayHelper Helper(ArrayProperty, ArrayProperty->ContainerPtrToValuePtr<uint8>(Template));
						if (Helper.IsValidIndex(GraphProperty->ArrayIndex))
						{
							if (const uint8* DefaultValue = Helper.GetRawPtr(GraphProperty->ArrayIndex))
							{
								FBlueprintEditorUtils::PropertyValueToString_Direct(ArrayProperty->Inner, DefaultValue, TextValue, Template);
							}
						}
					}
					else
					{
						const uint8* DefaultValue = Property->ContainerPtrToValuePtrForDefaults<uint8>(Template->GetClass(), Template, GraphProperty->ArrayIndex);
						FBlueprintEditorUtils::PropertyValueToString_Direct(Property, DefaultValue, TextValue, Template);
					}
					
					// Special handling in PinDefaultValueChanged which TrySetDefaultValue calls and would be nice to avoid. (It is avoided if SetPinAutogeneratedDefaultValue worked)
					bGeneratedDefaultValueBeingSet = true;

					const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(GetSchema());
					if (ResultPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Text && !ResultPin->PinType.IsContainer())
					{
						// Text needs special handling to preserve localization key from CDO. bPreserveTextIdentity is false when using TrySetDefaultValue.
						FString UseDefaultValue;
						TObjectPtr<UObject> UseDefaultObject = nullptr;
						FText UseDefaultText;

						Schema->GetPinDefaultValuesFromString(ResultPin->PinType, ResultPin->GetOwningNodeUnchecked(),
							TextValue, UseDefaultValue, UseDefaultObject, UseDefaultText, true);

						// The package may still be set to the CDO's package. If we don't change it here when it eventually gets
						// set to the property TextHistory.cpp will fail and generate a new key guid.
						// Always use the instance for the correct package, even if we're loading from an archetype.
						const USMNodeInstance* InstanceTemplate = GetOwningTemplate();
						check(InstanceTemplate);

						// Localization keys can change if we match CDO.
						if (HasDefaultValueExplicitlyBeenChanged())
						{
							const FText OldText = LD::TextUtils::StringBufferToText(LastAutoGeneratedDefaultValue);

							const TOptional<FString> LastNamespace = FTextInspector::GetNamespace(OldText);
							const TOptional<FString> CurrentNamespace = FTextInspector::GetNamespace(UseDefaultText);
							if (LastNamespace.IsSet() && CurrentNamespace.IsSet() && *LastNamespace == *CurrentNamespace)
							{
								const TOptional<FString> LastKey = FTextInspector::GetKey(OldText);
								const TOptional<FString> CurrentKey = FTextInspector::GetKey(UseDefaultText);
								if (LastKey.IsSet() && CurrentKey.IsSet() && *LastKey != *CurrentKey)
								{
									// If the text hasn't changed then that means key has purposely been changed and we should allow it.
									if (!OldText.EqualTo(UseDefaultText, ETextComparisonLevel::Quinary))
									{
										// Text has changed, try to persist the old key.
										if (LD::TextUtils::SetTemporaryKeyForTextReferences(this,
											UseDefaultText.ToString(), *CurrentNamespace, *LastKey, *CurrentKey))
										{
											UseDefaultText = FText::ChangeKey(*CurrentNamespace, *LastKey, UseDefaultText);
											TextValue = LD::TextUtils::TextToStringBuffer(UseDefaultText);
										}
									}
								}
							}
						}

						ConformLocalizationPackage(ResultPin->PinType, TextValue, UseDefaultText, InstanceTemplate->GetPackage());
					}

					Modify(false);
					ResultPin->Modify(false);

					// Manually set and track generated default value. Using SetPinAutogeneratedDefaultValue does not work as expected.
					LastAutoGeneratedDefaultValue = TextValue;

					const FText PreviousTextValue = ResultPin->DefaultTextValue;
					const FString PreviousStringValue = ResultPin->DefaultValue;
					const UObject* PreviousObjectValue = ResultPin->DefaultObject;

					Schema->TrySetDefaultValue(*ResultPin, TextValue, false);

					// Check for modification to the current pin value. If it has changed the blueprint should be modified so it can be compiled
					// and saved. This case is generally because a node construction script has modified this value.
					// This branch may be hit on load which will help signal users to save their blueprints because the default data changed.
					{
						bool bDefaultValueModified = false;
						if (ResultPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
						{
							// Value could be empty or false for booleans.
							bDefaultValueModified = ResultPin->DefaultValue.ToBool() != PreviousStringValue.ToBool();
						}
						else
						{
							bDefaultValueModified = ResultPin->DefaultValue != PreviousStringValue;
						}

						const bool bModify = bDefaultValueModified || ResultPin->DefaultObject != PreviousObjectValue ||
							!ResultPin->DefaultTextValue.EqualTo(PreviousTextValue);

						if (bModify)
						{
							UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForNodeChecked(this);
							FBlueprintEditorUtils::MarkBlueprintAsModified(Blueprint);
						}
					}

					bGeneratedDefaultValueBeingSet = false;
				}
			}
		}
	}
}

UScriptStruct* USMGraphK2Node_PropertyNode_Base::GetRuntimePropertyNodeType() const
{
	if (FStructProperty* StructProperty = GetRuntimePropertyNodeProperty())
	{
		return StructProperty->Struct;
	}

	return nullptr;
}

FStructProperty* USMGraphK2Node_PropertyNode_Base::GetRuntimePropertyNodeProperty() const
{
	if (FStructProperty* StructProperty = GetPropertyNodeProperty(true))
	{
		return StructProperty;
	}

	return GetPropertyNodeProperty(false);
}

FStructProperty* USMGraphK2Node_PropertyNode_Base::GetPropertyNodeProperty(bool bRuntimeOnly) const
{
	UScriptStruct* BaseFStruct = FSMGraphProperty_Base_Runtime::StaticStruct();
	UScriptStruct* ExcludeClass = FSMGraphProperty_Base::StaticStruct();

	for (TFieldIterator<FProperty> PropIt(GetClass(), EFieldIteratorFlags::IncludeSuper); PropIt; ++PropIt)
	{
		if (FStructProperty* StructProp = CastField<FStructProperty>(*PropIt))
		{
			if (StructProp->Struct->IsChildOf(BaseFStruct) && (!bRuntimeOnly || !StructProp->Struct->IsChildOf(ExcludeClass)))
			{
				return StructProp;
			}
		}
	}

	return nullptr;
}

USMNodeInstance* USMGraphK2Node_PropertyNode_Base::GetOwningTemplate() const
{
	if (!OwningGraphNode)
	{
		return nullptr;
	}

	const FSMGraphProperty_Base* PropertyNode = GetPropertyNodeConstChecked();
	if (USMNodeInstance* NodeInstance = OwningGraphNode->GetNodeTemplateFromGuid(PropertyNode->GetGuid()))
	{
		return NodeInstance;
	}

	if (PropertyNode->GetTemplateGuid().IsValid())
	{
		/*
		 * This is a stack template but the template could not be found!
		 * This *should* only occur when copy & pasting and the stack hasn't fully regenerated.
		 */
		return nullptr;
	}

	// Fallback to original behavior since the guid template tracking won't be setup on < 2.4 imports.
	return OwningGraphNode->GetNodeTemplate();
}

USMNodeBlueprint* USMGraphK2Node_PropertyNode_Base::GetTemplateBlueprint() const
{
	if (USMNodeInstance* Instance = GetOwningTemplate())
	{
		return Cast<USMNodeBlueprint>(UBlueprint::GetBlueprintFromClass(Instance->GetClass()));
	}

	return nullptr;
}

UEdGraph* USMGraphK2Node_PropertyNode_Base::GetOwningGraph() const
{
	return OwningGraphNode ? OwningGraphNode->GetGraphPropertyGraph(const_cast<USMGraphK2Node_PropertyNode_Base*>(this)->GetPropertyNodeChecked()->GetGuid()) : nullptr;
}

USMGraphNode_Base* USMGraphK2Node_PropertyNode_Base::GetOwningGraphNode() const
{
	return OwningGraphNode;
}

USMGraphNode_Base* USMGraphK2Node_PropertyNode_Base::GetOwningGraphNodeChecked() const
{
	USMGraphNode_Base* GraphNode = GetOwningGraphNode();
	check(GraphNode);
	return GraphNode;
}

void USMGraphK2Node_PropertyNode_Base::JumpToPropertyGraph()
{
	FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(GetPropertyGraph());
}

void USMGraphK2Node_PropertyNode_Base::JumpToTemplateBlueprint()
{
	if (UBlueprint* TemplateBlueprint = GetTemplateBlueprint())
	{
		FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(TemplateBlueprint);
	}
}

TSharedPtr<SSMGraphProperty_Base> USMGraphK2Node_PropertyNode_Base::GetGraphNodeWidget() const
{
	return nullptr;
}

TSharedPtr<SWidget> USMGraphK2Node_PropertyNode_Base::GetGraphDetailWidget() const
{
	TSharedRef<SHorizontalBox> DetailWidget = SNew(SHorizontalBox);
	DetailWidget->AddSlot()
	.AutoWidth()
	[
		GetViewGraphDetailWidget().ToSharedRef()
	];

	if (GetPropertyNodeConstChecked()->AllowToggleGraphEdit())
	{
		DetailWidget->AddSlot()
		.AutoWidth()
		[
			GetToggleEditGraphDetailWidget().ToSharedRef()
		];
	}

	return DetailWidget;
}

TSharedPtr<SWidget> USMGraphK2Node_PropertyNode_Base::GetViewGraphDetailWidget() const
{
	UEdGraph* Graph = GetOwningGraph();
	check(Graph);
	const FText EditGraphText = Graph->bEditable ? LOCTEXT("EditGraphProperty", "Edit Graph") : LOCTEXT("ViewGraphProperty", "View Graph");
	
	return SNew(SButton)
		.Text(EditGraphText)
		.OnClicked_Lambda([this]()
		{
			if (UEdGraph* Graph = this->GetOwningGraph())
			{
				FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(Graph);
			}
			return FReply::Handled();
		});
}

TSharedPtr<SWidget> USMGraphK2Node_PropertyNode_Base::GetToggleEditGraphDetailWidget() const
{
	USMPropertyGraph* Graph = Cast<USMPropertyGraph>(GetOwningGraph());
	check(Graph);
	const FText EditGraphText = Graph->IsGraphBeingUsedToEdit() ? LOCTEXT("DisableGraphEdit", "Revert to Node Edit") : LOCTEXT("EnableGraphEdit", "Convert to Graph Edit");

	return SNew(SButton)
		.Text(EditGraphText)
		.OnClicked_Lambda([this]()
		{
			if (USMPropertyGraph* Graph = Cast<USMPropertyGraph>(this->GetOwningGraph()))
			{
				Graph->ToggleGraphPropertyEdit();
			}
			return FReply::Handled();
		});
}

void USMGraphK2Node_PropertyNode_Base::GetContextMenuActionsForOwningNode(const UEdGraph* CurrentGraph,
                                                                     const UEdGraphNode* InGraphNode, const UEdGraphPin* InGraphPin, class UToolMenu* ToolMenu, bool bIsDebugging) const
{
	// This flag is normally cleared unless a right mouse click was detected.
	bMouseOverNodeProperty = false;
	
	FSMBlueprintEditor* Editor = FSMBlueprintEditorUtils::GetStateMachineEditor(this);
	check(Editor);
	Editor->SelectedPropertyNode = const_cast<USMGraphK2Node_PropertyNode_Base*>(this);

	FSMGraphProperty_Base* GraphProperty = GetPropertyNodeConstChecked();
	FToolMenuSection& Section = ToolMenu->AddSection("SMPropertyGraphSchemaActions", GraphProperty->GetDisplayName());
	Internal_GetContextMenuActionsForOwningNode(CurrentGraph, InGraphNode, InGraphPin, Section, bIsDebugging);
}

UEdGraphPin* USMGraphK2Node_PropertyNode_Base::GetResultPin() const
{
	if (UEdGraphPin* Pin = FindPin(GetPropertyNodeConstChecked()->VariableName))
	{
		return Pin;
	}
	
	return FindPin(TEXT("Result"));
}

bool USMGraphK2Node_PropertyNode_Base::DoesResultPinHaveConnections() const
{
	if (const UEdGraphPin* ResultPin = GetResultPin())
	{
		return ResultPin->LinkedTo.Num() > 0;
	}

	return false;
}

bool USMGraphK2Node_PropertyNode_Base::IsValueSetToDefault() const
{
	if (bDefaultValueChanged)
	{
		return false;
	}
	
	if (const UEdGraphPin* ResultPin = GetResultPin())
	{
		return ResultPin->DefaultValue == ResultPin->AutogeneratedDefaultValue || ResultPin->DefaultValue == LastAutoGeneratedDefaultValue;
	}

	return false;
}

bool USMGraphK2Node_PropertyNode_Base::IsValueModifiedOrWired() const
{
	return !IsValueSetToDefault() || DoesResultPinHaveConnections();
}

void USMGraphK2Node_PropertyNode_Base::SetHighlightedArgs(const FHighlightArgs& InHighlightArgs)
{
	HighlightArgs = InHighlightArgs;
}

void USMGraphK2Node_PropertyNode_Base::SetNotificationArgs(const FNotifyArgs& InNotifyArgs)
{
	NotifyArgs = InNotifyArgs;
}

void USMGraphK2Node_PropertyNode_Base::ConformLocalizationPackage(const FEdGraphPinType& PinType,
                                                                  FString& InOutTextString, const FText& DefaultTextValue, const UObject* Package)
{
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Text &&
		!PinType.IsContainer() &&
		!InOutTextString.IsEmpty() &&
		DefaultTextValue.ShouldGatherForLocalization())
	{
		TOptional<FString> CurrentNamespace = FTextInspector::GetNamespace(DefaultTextValue);
		if (CurrentNamespace.IsSet())
		{
			TOptional<FString> Key = FTextInspector::GetKey(DefaultTextValue);
			if (Key.IsSet())
			{
				FText TextValue;
				const TCHAR* Success = FTextStringHelper::ReadFromBuffer(*InOutTextString, TextValue);
				check(Success);

				const FString RealPackageNamespace = TextNamespaceUtil::GetPackageNamespace(Package);
				const FString CurrentPackageNamespace = TextNamespaceUtil::ExtractPackageNamespace(*CurrentNamespace);

				// No current package likely means native property not using LOCTEXT. UE should set this on save.
				if (!CurrentPackageNamespace.IsEmpty() &&
					RealPackageNamespace != CurrentPackageNamespace &&
					DefaultTextValue.ToString() == TextValue.ToString())
				{
					const FString CurrentTextNamespace = TextNamespaceUtil::StripPackageNamespace(*CurrentNamespace);
					const FString FullDesiredNamespace = TextNamespaceUtil::BuildFullNamespace(CurrentTextNamespace,
						RealPackageNamespace, /*bAlwaysApplyPackageNamespace*/ true);
			
					InOutTextString.Empty();
					TextValue = FText::ChangeKey(FullDesiredNamespace, *Key, TextValue);
			
					FTextStringHelper::WriteToBuffer(InOutTextString, TextValue);
				}
			}
		}
	}
}

void USMGraphK2Node_PropertyNode_Base::Internal_GetContextMenuActionsForOwningNode(const UEdGraph* CurrentGraph,
                                                                                   const UEdGraphNode* InGraphNode, const UEdGraphPin* InGraphPin, FToolMenuSection& MenuSection, bool bIsDebugging) const
{
	MenuSection.AddMenuEntry(FSMEditorCommands::Get().GoToPropertyGraph);

	if (!bIsDebugging)
	{
		if (GetPropertyGraph()->IsGraphBeingUsedToEdit())
		{
			MenuSection.AddMenuEntry(FSMEditorCommands::Get().RevertPropertyToNodeEdit);
		}
		else
		{
			MenuSection.AddMenuEntry(FSMEditorCommands::Get().ConvertPropertyToGraphEdit);
		}

		MenuSection.AddMenuEntry(FSMEditorCommands::Get().ResetGraphProperty);
	}
}

#undef LOCTEXT_NAMESPACE
