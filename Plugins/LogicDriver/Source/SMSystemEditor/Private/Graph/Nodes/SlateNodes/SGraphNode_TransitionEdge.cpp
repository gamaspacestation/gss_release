// Copyright Recursoft LLC 2019-2022. All Rights Reserved.

#include "SGraphNode_TransitionEdge.h"
#include "Graph/ConnectionDrawing/SMGraphConnectionDrawingPolicy.h"
#include "Graph/Nodes/SMGraphNode_RerouteNode.h"
#include "Graph/Nodes/SMGraphNode_StateNode.h"
#include "Graph/Nodes/SMGraphNode_TransitionEdge.h"
#include "Graph/SMTransitionGraph.h"
#include "Graph/Pins/SGraphPin_StatePin.h"
#include "Utilities/SMBlueprintEditorUtils.h"
#include "Utilities/SMNodeInstanceUtils.h"

#include "Widgets/Images/SImage.h"
#include "Widgets/Layout/SSpacer.h"
#include "Widgets/SBoxPanel.h"
#include "Widgets/SToolTip.h"
#include "Widgets/Text/SInlineEditableTextBlock.h"
#include "SGraphPanel.h"
#include "SGraphPreviewer.h"
#include "Configuration/SMEditorStyle.h"
#include "SKismetLinearExpression.h"
#include "SMUnrealTypeDefs.h"

#define LOCTEXT_NAMESPACE "SSMTransitionEdge"

void SSMTransitionShorthandView::Construct(const FArguments& InArgs, USMGraphNode_TransitionEdge* InTransitionEdge)
{
	TransitionEdge = InTransitionEdge;
	check(TransitionEdge);

	TSharedPtr<SVerticalBox> VerticalBox;
	
	ChildSlot
	[
		SAssignNew(VerticalBox, SVerticalBox)
	];

	if (!TransitionEdge->IsUsingDefaultNodeClass())
	{
		if (const USMNodeInstance* Template = TransitionEdge->GetNodeTemplate())
		{
			const TSharedPtr<SWidget> NodeClassWidget = FSMNodeInstanceUtils::CreateNodeClassWidgetDisplay(Template);
			VerticalBox->AddSlot()
			[
				NodeClassWidget.ToSharedRef()
			];
		}
	}

	UEdGraphPin* PinToEval = TransitionEdge->GetLinearExpressionPin();
	VerticalBox->AddSlot()
	.HAlign(HAlign_Fill)
	.AutoHeight()
	.Padding(FMargin(0.f, 4.f,  0.f, 0.f))
	[
		SNew(SHorizontalBox)
		+ SHorizontalBox::Slot()
		.AutoWidth()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
				.Text(LOCTEXT("ConditionName", "Condition:"))
				.TextStyle(FSMUnrealAppStyle::Get(), TEXT("KismetExpression.ReadAutogeneratedVariable"))
		]
		+ SHorizontalBox::Slot()
		.AutoWidth()
		.VAlign(VAlign_Fill)
		.Padding(FMargin(6.f,4.f))
		[
			SNew(SKismetLinearExpression, PinToEval)
				.IsEditable(false)
				.Visibility(EVisibility::HitTestInvisible)
		]
	];

	if (!TransitionEdge->DelegatePropertyName.IsNone())
	{
		VerticalBox->AddSlot()
		[
			SNew(SHorizontalBox)
			+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			[
				SNew(STextBlock)
					.Text(LOCTEXT("EventName", "Event:"))
					.TextStyle(FSMUnrealAppStyle::Get(), TEXT("KismetExpression.ReadAutogeneratedVariable"))
			]
			+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(FMargin(6.f,4.f))
			[
				SNew(STextBlock)
					.Text(FText::FromName(TransitionEdge->DelegatePropertyName))
					.TextStyle(FSMUnrealAppStyle::Get(), TEXT("KismetExpression.ReadAutogeneratedVariable"))
			]
		];
	}
}

void SGraphNode_TransitionEdge::Construct(const FArguments& InArgs, USMGraphNode_Base* InNode)
{
	SGraphNode_BaseNode::Construct(SGraphNode_BaseNode::FArguments(), InNode);
	CastChecked<USMGraphNode_Base>(GraphNode)->OnWidgetConstruct();
	UpdateGraphNode();
}

void SGraphNode_TransitionEdge::Tick(const FGeometry& AllottedGeometry, const double InCurrentTime,
	const float InDeltaTime)
{
	SGraphNode::Tick(AllottedGeometry, InCurrentTime, InDeltaTime);

	CastChecked<USMGraphNode_Base>(GraphNode)->UpdateTime(InDeltaTime);
}

void SGraphNode_TransitionEdge::MoveTo(const FVector2D& NewPosition, FNodeSet& NodeFilter, bool bMarkDirty)
{
	if (GraphNode->IsA<USMGraphNode_RerouteNode>())
	{
		SGraphNode_BaseNode::MoveTo(NewPosition, NodeFilter, bMarkDirty);
	}
	// else position set by states.
}

bool SGraphNode_TransitionEdge::RequiresSecondPassLayout() const
{
	return GraphNode && GraphNode->IsA<USMGraphNode_TransitionEdge>();
}

void SGraphNode_TransitionEdge::PerformSecondPassLayout(const TMap< UObject*, TSharedRef<SNode> >& NodeToWidgetLookup) const
{
	USMGraphNode_TransitionEdge* EdgeNode = CastChecked<USMGraphNode_TransitionEdge>(GraphNode);

	FGeometry StartGeom;
	FGeometry EndGeom;

	int32 ThisIndex = 0;
	int32 TransitionCount = 1;

	USMGraphNode_StateNodeBase* FromState = EdgeNode->GetFromState(true);
	USMGraphNode_StateNodeBase* ToState = EdgeNode->GetToState(true);
	if (FromState && ToState)
	{
		const TSharedRef<SNode>* pFromWidget = NodeToWidgetLookup.Find(FromState);
		const TSharedRef<SNode>* pToWidget = NodeToWidgetLookup.Find(ToState);
		if (pFromWidget && pToWidget)
		{
			const TSharedRef<SNode>& FromWidget = *pFromWidget;
			const TSharedRef<SNode>& ToWidget = *pToWidget;

			StartGeom = FGeometry(FVector2D(FromState->NodePosX, FromState->NodePosY), FVector2D::ZeroVector, FromWidget->GetDesiredSize(), 1.0f);
			EndGeom = FGeometry(FVector2D(ToState->NodePosX, ToState->NodePosY), FVector2D::ZeroVector, ToWidget->GetDesiredSize(), 1.0f);

			TArray<USMGraphNode_TransitionEdge*> Transitions;
			FromState->GetOutputTransitions(Transitions);

			Transitions = Transitions.FilterByPredicate([ToState](const USMGraphNode_TransitionEdge* InTransition) -> bool
			{
				return InTransition->GetToState(true) == ToState;
			});

			ThisIndex = Transitions.IndexOfByKey(EdgeNode);
			TransitionCount = Transitions.Num();
		}
	}

	PositionBetweenTwoNodesWithOffset(StartGeom, EndGeom, ThisIndex, TransitionCount);
}

void SGraphNode_TransitionEdge::UpdateGraphNode()
{
	InputPins.Empty();
	OutputPins.Empty();

	RightNodeBox.Reset();
	LeftNodeBox.Reset();

	this->SetVisibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &SGraphNode_TransitionEdge::GetIconVisibility)));
	this->ContentScale.Bind(this, &SGraphNode::GetContentScale);

	TSharedPtr<SVerticalBox> IconVerticalBox;
	TSharedPtr<SOverlay> PinArea;
	SOverlay::FOverlaySlot* PinPrimaryOverlaySlot;

	this->GetOrAddSlot(ENodeZone::Center)
	.HAlign(HAlign_Center)
	.VAlign(VAlign_Center)
	[
		SAssignNew(PinArea, SOverlay)
		+ SOverlay::Slot()
		.HAlign(HAlign_Fill)
		.VAlign(VAlign_Fill)
		.Expose(PinPrimaryOverlaySlot)
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			.HAlign(HAlign_Center)
			.Padding(2.5)
			[
				SNew(STextBlock)
				.Visibility(this, &SGraphNode_TransitionEdge::GetPriorityVisibility)
				.Font(FCoreStyle::Get().GetFontStyle("ExpandableArea.TitleFont"))
				.Text(this, &SGraphNode_TransitionEdge::GetPriorityAsText)
				.ToolTipText(LOCTEXT("TransitionPriorityTooltip", "Priority Order - lower numbers evaluate first."))
			]
			+SVerticalBox::Slot()
			.AutoHeight()
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			[
				SAssignNew(IconVerticalBox, SVerticalBox)
			]
		]
	];
	
	IconVerticalBox->AddSlot()
	.AutoHeight()
	.VAlign(VAlign_Center)
	.HAlign(HAlign_Center)
	[
		SNew(SOverlay)
		+SOverlay::Slot()
		.HAlign(HAlign_Fill)
		.VAlign(VAlign_Fill)
		[
			SNew(SImage)
			.Image(FSMUnrealAppStyle::Get().GetBrush("Graph.TransitionNode.ColorSpill"))
			.ColorAndOpacity(this, &SGraphNode_TransitionEdge::GetEdgeColor, -1)
		]
		+SOverlay::Slot()
		[
			SNew(SImage)
			.Image(this, &SGraphNode_TransitionEdge::GetIcon, -1)
		]
	];

	if (USMGraphNode_TransitionEdge* TransitionNode = GetTransition())
	{
		for (int32 TransitionIdx = 0; TransitionIdx < TransitionNode->TransitionStack.Num(); ++TransitionIdx)
		{
			FTransitionStackContainer& StackTemplate = TransitionNode->TransitionStack[TransitionIdx];
			if (StackTemplate.NodeStackInstanceTemplate)
			{
				IconVerticalBox->AddSlot()
				.AutoHeight()
				.Padding(0.f, 2.f, 0.f, 0.f)
				.HAlign(HAlign_Center)
				.VAlign(VAlign_Center)
				[
					SNew(SOverlay)
					+SOverlay::Slot()
					.HAlign(HAlign_Fill)
					.VAlign(VAlign_Fill)
					[
						SNew(SImage)
						.Image(FSMUnrealAppStyle::Get().GetBrush("Graph.TransitionNode.ColorSpill"))
						.ColorAndOpacity(this, &SGraphNode_TransitionEdge::GetEdgeColor, TransitionIdx)
					]
					+SOverlay::Slot()
					[
						SAssignNew(StackTemplate.IconImage, SImage)
						.Image(this, &SGraphNode_TransitionEdge::GetIcon, TransitionIdx)
					]
				];
			}
		}
	}

	if (GraphNode->IsA<USMGraphNode_RerouteNode>())
	{
		check(PinPrimaryOverlaySlot);
		PinPrimaryOverlaySlot->SetPadding(GetRerouteNodePadding());

		PinArea->AddSlot()
		.HAlign(HAlign_Fill)
		.VAlign(VAlign_Fill)
		[
			SAssignNew(RightNodeBox, SVerticalBox)
		];

		PinArea->AddSlot()
		.Padding(GetRerouteNodePadding())
		[
			SNew(SSpacer)
			.Size(GetRerouteNodeSpacerSize())
			.Visibility(EVisibility::Visible)
			.Cursor(EMouseCursor::CardinalCross)
		];
	}

	CreatePinWidgets();
}

void SGraphNode_TransitionEdge::CreatePinWidgets()
{
	if (const USMGraphNode_RerouteNode* RerouteNode = Cast<USMGraphNode_RerouteNode>(GraphNode))
	{
		UEdGraphPin* PinToUse = RerouteNode->GetOutputPin();
		if (!PinToUse)
		{
			// For cases where there is no output pin.
			PinToUse = RerouteNode->GetInputPin();
		}

		if (!PinToUse->bHidden)
		{
			const TSharedPtr<SGraphPin> NewPin = SNew(SSMGraphPin_StatePin, PinToUse);
			this->AddPin(NewPin.ToSharedRef());
		}
	}
	else if (const USMGraphNode_TransitionEdge* TransitionEdge = Cast<USMGraphNode_TransitionEdge>(GraphNode))
	{
		// Transition edges shouldn't actually display a pin, but we need to add one so the SGraphPanel::OnMouseButtonDoubleClick
		// will correctly find the pin and call USMGraphSchema::OnPinConnectionDoubleCicked, where we handle inserting reroute nodes.
		const TSharedPtr<SGraphPin> Pin = CreatePinWidget(TransitionEdge->GetInputPin());
		Pin->SetOwner(SharedThis(this));
		InputPins.Add(Pin.ToSharedRef());
	}
}

void SGraphNode_TransitionEdge::AddPin(const TSharedRef<SGraphPin>& PinToAdd)
{
	check(GraphNode->IsA<USMGraphNode_RerouteNode>());

	PinToAdd->SetOwner(SharedThis(this));
	RightNodeBox->AddSlot()
		.HAlign(HAlign_Fill)
		.VAlign(VAlign_Fill)
		.FillHeight(1.0f)
		[
			PinToAdd
		];
	OutputPins.Add(PinToAdd);
}

TSharedPtr<SToolTip> SGraphNode_TransitionEdge::GetComplexTooltip()
{
	/* Display a pop-up on mouse hover with useful information. */

	USMGraphNode_TransitionEdge* TransitionNode = GetTransition();
	if (TransitionNode == nullptr)
	{
		return SNew(SToolTip);
	}

	bool bHasOnEnteredLogic = false;
	bool bHasInitLogic = false;
	bool bHasShutdownLogic = false;
	bool bHasPreEvalLogic = false;
	bool bHasPostEvalLogic = false;
	const bool bIsDefaultClass = TransitionNode->IsUsingDefaultNodeClass();

	USMGraphNode_StateNodeBase* FromStateNode = TransitionNode->GetFromState();

	if (const USMTransitionGraph* TransitionGraph = Cast<USMTransitionGraph>(TransitionNode->GetBoundGraph()))
	{
		bHasOnEnteredLogic = bIsDefaultClass && TransitionGraph->HasTransitionEnteredLogic();
		bHasInitLogic = bIsDefaultClass && FromStateNode != nullptr && TransitionGraph->HasInitLogic();
		bHasShutdownLogic = bIsDefaultClass && FromStateNode != nullptr && TransitionGraph->HasShutdownLogic();
		bHasPreEvalLogic = TransitionGraph->HasPreEvalLogic();
		bHasPostEvalLogic = TransitionGraph->HasPostEvalLogic();
	}

	const FSlateBrush* FastPathImageBrush = FSMEditorStyle::Get()->GetBrush(TEXT("SMGraph.FastPath_32x"));
	
	const TSharedRef<SVerticalBox> Widget = SNew(SVerticalBox);
	Widget->AddSlot()
		.AutoHeight()
		.Padding(FMargin(0.f, 0.f, 0.f, 4.f))
		[
			SNew(SHorizontalBox)
			+ SHorizontalBox::Slot()
			.AutoWidth()
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Title")
				.Text(FText::Format(LOCTEXT("TransitionPopupTitle", "{0} (Transition)"), FText::FromString(TransitionNode->GetTransitionName())))
			]
			+ SHorizontalBox::Slot()
			.AutoWidth()
			.Padding(0.f, -4.f, 0.f, 0.f)
			[
				SNew(SImage)
				.Image(FastPathImageBrush)
				.Visibility_Lambda([TransitionNode]()
				{
					return TransitionNode && TransitionNode->IsNodeFastPathEnabled() ? EVisibility::Visible : EVisibility::Collapsed;
				})
			]
		];
	
	// Selected transition
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(2.0f)
			[
				// Take the expression connected to the eval pin and turn it into text.
				SNew(SSMTransitionShorthandView, TransitionNode)
			];
	}
	
	if (bHasOnEnteredLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(FMargin(2.f, 4.f, 2.f, 4.f))
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Info")
				.Text(LOCTEXT("TransitionEnteredTooltip", "Transition Entered: Logic will execute when entering this transition"))
			];
	}

	if (bHasInitLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(FMargin(2.f, 4.f, 2.f, 4.f))
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Info")
				.Text(FText::Format(LOCTEXT("TransitionInitTooltip", "Transition Initialization: Logic will execute when state '{0}' has started"), FText::FromString(FromStateNode->GetStateName())))
			];
	}

	if (bHasShutdownLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(FMargin(2.f, 4.f, 2.f, 4.f))
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Info")
				.Text(FText::Format(LOCTEXT("TransitionShutdownTooltip", "Transition Shutdown: Logic will execute when state '{0}' has exited"), FText::FromString(FromStateNode->GetStateName())))
			];
	}

	if (bHasPreEvalLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(FMargin(2.f, 4.f, 2.f, 4.f))
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Warning")
				.Text(LOCTEXT("TransitionPreEvalTooltip", "Transition Pre-Eval: Logic will execute before each evaluation"))
			];
	}

	if (bHasPostEvalLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			.Padding(FMargin(2.f, 4.f, 2.f, 4.f))
			[
				SNew(STextBlock)
				.TextStyle(FSMEditorStyle::Get(), "SMGraph.Tooltip.Warning")
				.Text(LOCTEXT("TransitionPostEvalTooltip", "Transition Post-Eval: Logic will execute after each evaluation"))
			];
	}

	if (bHasOnEnteredLogic || bHasInitLogic || bHasShutdownLogic || bHasPreEvalLogic || bHasPostEvalLogic)
	{
		Widget->AddSlot()
			.AutoHeight()
			[
				SNew(SGraphPreviewer, TransitionNode->GetBoundGraph())
				.ShowGraphStateOverlay(false)
			];
	}

	return SNew(SToolTip)
		[
			Widget
		];
}

const FSlateBrush* SGraphNode_TransitionEdge::GetShadowBrush(bool bSelected) const
{
	return !bSelected ? FStyleDefaults::GetNoBrush() : SGraphNode_BaseNode::GetShadowBrush(bSelected);
}

void SGraphNode_TransitionEdge::OnMouseEnter(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)
{
	const USMGraphNode_Base* Node = CastChecked<USMGraphNode_Base>(GraphNode);
	if (UEdGraphPin* Pin = Node->GetInputPin())
	{
		GetOwnerPanel()->AddPinToHoverSet(Pin);
	}

	SGraphNode::OnMouseEnter(MyGeometry, MouseEvent);
}

void SGraphNode_TransitionEdge::OnMouseLeave(const FPointerEvent& MouseEvent)
{
	const USMGraphNode_Base* Node = CastChecked<USMGraphNode_Base>(GraphNode);
	if (UEdGraphPin* Pin = Node->GetInputPin())
	{
		GetOwnerPanel()->RemovePinFromHoverSet(Pin);
	}

	SGraphNode::OnMouseLeave(MouseEvent);
}

void SGraphNode_TransitionEdge::PositionBetweenTwoNodesWithOffset(const FGeometry& StartGeom, const FGeometry& EndGeom, int32 NodeIndex, int32 MaxNodes) const
{
	// Get a reasonable seed point (halfway between the boxes)
	const FVector2D StartCenter = FGeometryHelper::CenterOf(StartGeom);
	const FVector2D EndCenter = FGeometryHelper::CenterOf(EndGeom);

	if (StartCenter == EndCenter)
	{
		FVector2D Corner = StartCenter;
		Corner.X += StartGeom.Size.X / 2.f + 10.f;
		Corner.Y += StartGeom.Size.Y / 2.f + 15.f;

		GraphNode->NodePosX = Corner.X;
		GraphNode->NodePosY = Corner.Y;

		return;
	}

	const FVector2D SeedPoint = (StartCenter + EndCenter) * 0.5f;

	// Find the (approximate) closest points between the two boxes
	const FVector2D StartAnchorPoint = FGeometryHelper::FindClosestPointOnGeom(StartGeom, SeedPoint);
	const FVector2D EndAnchorPoint = FGeometryHelper::FindClosestPointOnGeom(EndGeom, SeedPoint);

	// Position ourselves halfway along the connecting line between the nodes, elevated away perpendicular to the direction of the line
	const float Height = 30.0f;

	FVector2D DesiredNodeSize = GetDesiredSize();
	DesiredNodeSize.Y += GetDesiredYOffset();
	
	FVector2D DeltaPos(EndAnchorPoint - StartAnchorPoint);

	if (DeltaPos.IsNearlyZero())
	{
		DeltaPos = FVector2D(10.0f, 0.0f);
	}

	const FVector2D Normal = FVector2D(DeltaPos.Y, -DeltaPos.X).GetSafeNormal();

	USMGraphNode_TransitionEdge* TransitionEdge = CastChecked<USMGraphNode_TransitionEdge>(GraphNode);
	USMTransitionInstance* Instance = TransitionEdge->GetNodeTemplateAs<USMTransitionInstance>();

	const float LocationPercent = Instance ? Instance->GetIconLocationPercentage() : 0.5f;
	const FVector2D NewCenter = StartAnchorPoint + (LocationPercent * DeltaPos) + (Height * Normal);

	FVector2D DeltaNormal = DeltaPos.GetSafeNormal();
	
	// Calculate node offset in the case of multiple transitions between the same two nodes
	// MultiNodeOffset: the offset where 0 is the center of the transition, -1 is 1 <size of node>
	// towards the PrevStateNode and +1 is 1 <size of node> towards the NextStateNode.

	const float MultiNodeSpace = 0.2f; // Space between multiple transition nodes (in units of <size of node> )
	const float MultiNodeStep = (1.f + MultiNodeSpace); //Step between node centres (Size of node + size of node spacer)

	const float MultiNodeStart = -((MaxNodes - 1) * MultiNodeStep) / 2.f;
	const float MultiNodeOffset = MultiNodeStart + (NodeIndex * MultiNodeStep);

	// Now we need to adjust the new center by the node size, zoom factor and multi node offset
	FVector2D NewCorner = NewCenter - (0.5f * DesiredNodeSize) + (DeltaNormal * MultiNodeOffset * DesiredNodeSize.Size());
	NewCorner.Y += GetDesiredYOffset();
	
	GraphNode->NodePosX = NewCorner.X;
	GraphNode->NodePosY = NewCorner.Y;
}

USMGraphNode_TransitionEdge* SGraphNode_TransitionEdge::GetTransition() const
{
	if (USMGraphNode_TransitionEdge* EdgeNode = Cast<USMGraphNode_TransitionEdge>(GraphNode))
	{
		return EdgeNode;
	}

	if (const USMGraphNode_RerouteNode* RerouteNode = Cast<USMGraphNode_RerouteNode>(GraphNode))
	{
		return RerouteNode->GetPrimaryTransition();
	}

	return nullptr;
}

FVector2D SGraphNode_TransitionEdge::GetTotalRerouteSpacerSize()
{
	return GetRerouteNodeSpacerSize() + GetRerouteNodePadding() * 2.f;
}

FSlateColor SGraphNode_TransitionEdge::GetEdgeColor(int32 InIndex) const
{
	const FLinearColor CustomIconColor = FLinearColor(1.f, 1.f, 1.f, 0.f);
	if (const USMGraphNode_TransitionEdge* EdgeNode = GetTransition())
	{
		// Base node.
		if (InIndex < 0)
		{
			const USMTransitionInstance* TransitionInstance = EdgeNode->GetNodeTemplateAs<USMTransitionInstance>();
			if (TransitionInstance && TransitionInstance->ShouldHideIconBackground())
			{
				return CustomIconColor;
			}
		}
		// Transition stack.
		else if (InIndex >= 0 && InIndex < EdgeNode->TransitionStack.Num())
		{
			const FTransitionStackContainer& StackElement = EdgeNode->TransitionStack[InIndex];
			if (StackElement.NodeStackInstanceTemplate && CastChecked<USMTransitionInstance>(StackElement.NodeStackInstanceTemplate)->ShouldHideIconBackground())
			{
				return CustomIconColor;
			}
		}
	}
	
	return FLinearColor(0.9f, 0.9f, 0.9f, 1.0f);
}

const FSlateBrush* SGraphNode_TransitionEdge::GetIcon(int32 InIndex) const
{
	if (USMGraphNode_TransitionEdge* EdgeNode = GetTransition())
	{
		if (const FSlateBrush* Brush = EdgeNode->GetTransitionIcon(InIndex))
		{
			if (Brush->ImageSize.GetMax() > 0)
			{
				return Brush;
			}
		}
	}

	return FSMUnrealAppStyle::Get().GetBrush(TEXT("Graph.TransitionNode.Icon"));
}

EVisibility SGraphNode_TransitionEdge::GetIconVisibility() const
{
	if (USMGraphNode_TransitionEdge* TransitionNode = GetTransition())
	{
		if (GraphNode->IsA<USMGraphNode_TransitionEdge>() && TransitionNode->IsRerouted() &&
			!FSMBlueprintEditorUtils::GetEditorSettings()->bDisplayTransitionIconWhenRerouted)
		{
			bool bIsConnectedToValidReroute = true;
			if (const USMGraphNode_RerouteNode* PrevReroute = TransitionNode->GetPreviousRerouteNode())
			{
				if (!PrevReroute->IsThisRerouteValid())
				{
					bIsConnectedToValidReroute = false;
				}
			}
			if (const USMGraphNode_RerouteNode* NextReroute = TransitionNode->GetNextRerouteNode())
			{
				if (!NextReroute->IsThisRerouteValid())
				{
					bIsConnectedToValidReroute = false;
				}
			}

			// Reroute nodes display the icon instead, but only if they're valid. This lets the actual transition
			// be selected if desired on invalid reroutes.
			if (bIsConnectedToValidReroute)
			{
				return EVisibility::Collapsed;
			}
		}
		else if (GraphNode->IsA<USMGraphNode_RerouteNode>())
		{
			return EVisibility::Visible;
		}

		const USMTransitionInstance* Instance = Cast<USMTransitionInstance>(TransitionNode->GetNodeTemplate());

		const bool bSelected = FSMBlueprintEditorUtils::IsNodeSelected(TransitionNode);
		return ((!TransitionNode->IsHovered() && !bSelected && Instance != nullptr && Instance->IsIconHidden()) ? EVisibility::Collapsed : EVisibility::Visible);
	}

	return EVisibility::Visible;
}

FText SGraphNode_TransitionEdge::GetPriorityAsText() const
{
	int32 PriorityOrder = 0;
	if (const USMGraphNode_TransitionEdge* TransitionNode = GetTransition())
	{
		if (const USMTransitionInstance* Instance = Cast<USMTransitionInstance>(TransitionNode->GetNodeTemplate()))
		{
			PriorityOrder = Instance->GetPriorityOrder();
		}
	}

	return FText::FromString(FString::FromInt(PriorityOrder));
}

EVisibility SGraphNode_TransitionEdge::GetPriorityVisibility() const
{
	return FSMBlueprintEditorUtils::GetEditorSettings()->bDisplayTransitionPriority ? EVisibility::Visible : EVisibility::Collapsed;
}

int32 SGraphNode_TransitionEdge::GetDesiredYOffset() const
{
	const int32 DesiredSizeYOffset = GetPriorityVisibility() == EVisibility::Visible ? -16.f /* Rough height of priority */ : 0.f;
	return DesiredSizeYOffset;
}

#undef LOCTEXT_NAMESPACE
